<!DOCTYPE html>
<html>
  <head>
    <title>Elm Horizon</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
    </style>
    <link href="styles/slides.css" rel="stylesheet">
  </head>
  <body>
    <textarea id="source" style="display: none">
class: title middle center
# 0-60 in 15 Minutes
## Building a Realtime App With Elm and Horizon.js

.logo[.elm[![Elm Logo](images/elm-logo.png "Elm Logo")]]

- Abadi Kurniawan
- Senior Developer @Engage Software

.social-media[
.twitter[.logo[![Twitter Logo](images/twitter.png "Twitter Logo")] [@abadikurniawan](https://twitter/abadikurniawan)]
.github[.logo[![Github Logo](images/github.png "Github Logo")] [abadi199](https://github/abadi199)]
]


???
Hi, My name is Abadi Kurniawan.
I'm a senior software developer at a st. louis based company called engage software, where I've been using elm in production for about 7 months.

Today, I will be talking about using elm with horizon js to build a realtime app.
---
class: elm heart center middle
# I .image[.elm-heart[![❤](images/heart.png "❤")]] Elm
???
I love elm. 

I think Elm is a great language and also Elm is really fun to use. 

---
class: center middle
.image[.face[![Happy](images/happy.png "happy")]]
???
This is pretty much how I feel whenever I have to work on my frontend code using Elm.
But the downside of Elm is, it makes you kinda like other languages a lot less.
---
class: center middle
.image[.face[![Frown](images/frown.png "Frown")]]

???
This is how I feel everytime I have to work on my backend code.
I just want to use Elm. But since we can't really use Elm in the backend yet, so we're stuck with other languages.

But what if there's another option. 
Maybe you don't have to write any backend code at all?
Maybe I can turn this frown face into a happy face again.
---
class: center middle
.image[.face[![Happy](images/happy.png "Happy")]]

---
class: center middle
# Horizon
???

---

class: horizon center middle
# What is Horizon?

.logo[.horizon[![Horizon Logo](images/horizon-logo.png "Horizon Logo")]]

???
So, what is horizon?

---
class: horizon center middle
### Horizon is a realtime, open source backend for JavaScript apps

[https://horizon.io](https://horizon.io)

???
Horizon is an open-source development platform for building realtime, scalable web apps. 
It's built on top of RethinkDB by the RethinkDB team, and runs on node.js.

If you're familiar with Firebase, horizon is similar to Firebase, but it's open source, and you can host your own horizon server on your own server.

With horizon, you can write realtime client side javascript application without writing backend code. 
---
class: horizon api center
## Horizon API
- Authentication
- Users & Groups
- Permissions
- Collection API
- Horizon API
???
Horizon provides several API. 
---
class: horizon api center
## Horizon API
- **Authentication**
- Users & Groups
- Permissions
- Collection API
- Horizon API

???
The first one is authentication. Horizon provides a way for your app to do user authentication.
---
class: horizon api center  
## Horizon API
- Authentication
- **Users & Groups**
- Permissions
- Collection API
- Horizon API

???
The second one is Users & Groups, which is how you manage the users and groups in their system when you use their authentication API. 
---
class: horizon api center  
## Horizon API
- Authentication
- Users & Groups
- **Permissions**
- Collection API
- Horizon API

???
and then we have Permissions API, which is how you configure the permissions, which users will have access to which data.
---
class: horizon api center  
## Horizon API
- Authentication
- Users & Groups
- Permissions
- **Collection API**
- Horizon API

???
the next one is Collection API. This is how you create, read, update, and delete data in the database.
---
class: horizon api center  
## Horizon API
- Authentication
- Users & Groups
- Permissions
- Collection API
- **Horizon API**

???
and the last one is Horizon API, which is the API to manage the connection to the horizon server itself, such as opening connection, error handling, and so on.
---
class: horizon api final center 
## Horizon API
- Authentication
- Users & Groups
- Permissions
- **Collection API**
- Horizon API

???
In this talk, I'm only going to cover Collection API.
---
class: horizon center collection write 
## Collection API

.table.medium.three-columns[
| Write       | Read    | Modifiers| 
|:-----------:|:-------:|:--------:|
| `remove`    | `fetch` | `above`
| `removeAll` | `watch` | `below`
| `insert`    |         | `find`
| `replace`   |         | `findAll`
| `store`     |         | `limit`
| `update`    |         | `order`
| `upsert`    |         |
]

???
What is collection?
In horizon, a Collection is an object represents a group of related documents, and it's backed by RethinkDB table. 
Collection API is a way for you to read and write into a collection, or RethinkDB table.

I'm grouping this API into 3 categories. This is not an official classification by Horizon. 
I just find it helpful to think about this API this way and how I can implement this in Elm.

The first category is the Write operations, which consists of remove, removeAll, insert, replace, store, update, and upsert. 
These are all operations that do some sort of writing/updating to the database. 

---
class: horizon center collection read
## Collection API

.table.medium.three-columns[
| Write       | Read    | Modifiers| 
|:-----------:|:-------:|:--------:|
| `remove`    | `fetch` | `above`
| `removeAll` | `watch` | `below`
| `insert`    |         | `find`
| `replace`   |         | `findAll`
| `store`     |         | `limit`
| `update`    |         | `order`
| `upsert`    |         |
]

???
The second category is Read operation, which contains fetch and watch. Both operations are use to read data from your collection, 
the difference is that with fetch, you only get the data once, similar to how select in sql works, while watch is you create a subscription to the data 
that you're interested in, and whenever there's some changes to these data, you will receive a new data.
---
class: horizon center collection modifiers
## Collection API

.table.medium.three-columns[
| Write       | Read    | Modifiers | 
|:-----------:|:-------:|:---------:|
| `remove`    | `fetch` | `above`
| `removeAll` | `watch` | `below`
| `insert`    |         | `find`
| `replace`   |         | `findAll`
| `store`     |         | `limit`
| `update`    |         | `order`
| `upsert`    |         |
]
???
The last category is Modifiers. This is the interesting one. So these are all operations that will "modify" your read operation. 
the way you use these modifiers operations are by applying them to your read operations. SO in a way, it modifies your read operations.

Above, below, find, and findAll are some kind of filtering modifiers.

Limit: will limit the number of data your want to get. 

And order, will sort the results based on certain fields. 
---
class: horizon
## Horizon.js - Example
```javascript
var messages = new Horizon()('chat_messages');
messages
    .findAll({from: 'elm'})
    .limit(5)
    .watch()
    .subscribe(data => { console.log(data); });

messages.insert({ from: 'elm', msg: 'Hello World!' });
// [{from:'elm',msg:'Hello World!'}]

messages.insert({ from: 'elm', msg: 'From Elm Conference' });
// [{from:'elm',msg:'Hello World!'},
// {from:'elm',msg:'From Elm Conference'}]

messages.insert({ from: 'abadi', msg: 'Just ignore me!' });
```
???
Let's say we want to build a simple chat app.
Here's a sample code of what my chat app could look like.
---
class: elm center middle
# Elm-Horizon
.logo[.elm[![Elm Logo](images/elm-logo.png "Elm Logo")]]
.logo[.horizon[![Horizon Logo](images/horizon-logo.png "Horizon Logo")]]
???
Ok, so how can we use horizon with elm in a nice way, 
so we don't have to write any code other than Elm code. 

Horizon provides a javascript client library, and we can use Ports and Subscriptions to communicate to this library.  
---
class: elm ports center middle
## Elm - Ports & Subscriptions

.diagram[.ports[![Ports & Subscriptions Diagram](images/ports.png "Ports & Subscriptions Diagram")]]

???
Let's talk about ports and subscriptions first.

Ports and Subscriptions are a way for elm to interop with javascripts. 

It's basically a message passing between elm and javascript, just like message passing between elm app and server. 

Similar to how you do message passing between client and server. But instead, it's between elm and javascript.

For sending data from elm to javascript, we use ports, and for receiving data from javascript to elm, we use subscriptions. 

and you can only send and receive a certain type of data, like string, integer, records, 

or if you want to send some arbitrary shaped of data, you can use json values. 
---
class: elm elm-horizon center middle
## Elm-Horizon
.diagram[.elm-horizon[![Elm Horizon Diagram](images/elm-horizon.png "Elm Horizon")]]

???
Now, let's see how we we can use ports and subscription with Horizon.

 So we'll use port to send json values out to horizon javascript client, and then we receive the json values back in using subscriptions. 
 
 Each read and write operations will have a pair of ports and subscriptions. 

In the case of read operation, which is watch and fetch, 

the data that will send out via port will be the information about the query, in this case the name of the collection,
and the modifiers.

and then we will receive the actual collection data via the subscription.

In the case of write operation, we send the data that we want to write to the collection via port,

and we use subscription to get the status of that operation.

and then the horizon javascript library will then handles all the network communication with the server.
---
class: elm center 
## Elm-Horizon
### Collection API

.table.wide.three-columns[
| Write              | Read           | Modifiers                | 
|:------------------:|:--------------:|:------------------------:|
| `removeCmd/Sub`    | `watchCmd/Sub` | `Above Json.Value`       |
| `removeAllCmd/Sub` | `fetchCmd/Sub` | `Below Json.Value`       |
| `insertCmd/Sub`    |                | `Find (List Json.Value)` |
| `replaceCmd/Sub`   |                | `FindAll Json.Value`     |
| `storeCmd/Sub`     |                | `Limit Int`              |
| `updateCmd/Sub`    |                | `Order String Direction` |
| `upsertCmd/Sub`    |                |                          |
]
???
So, here are those 3 categories of Collection API look like in Elm. 

We have pairs of command and subscription functions for each read and write actions. 

The command is for sending message out to horizon js, and the subscription is to receive the message back from horizon js.

The modifiers is a little bit different. Here, modifiers are implemented as union types
 
with each constructor requires data relevant to what the modifier is trying to do. 

Above, Below, Find, and FindAll constructors require Json value which is the criteria of the filter. 

Limit constructor requires an integer, which is the number of data you want to get.

and Order contructor requires a String, which is the name of the field you want to sort by,

and a union types called Direction, that can be either Descending or Ascending.
---
class: elm
## watchCmd/Sub
```elm
watchCmd : String -> List Modifier -> Cmd msg
watchCmd collectionName modifiers = ...
   
watchSub : Decoder a -> (Result Error (List (Maybe a)) -> msg) -> Sub msg
watchSub decoder tagger = ...
```
#### Example 
```elm
init = ( initialModel
        , watchCmd "chat_messages"
            [ FindAll <| encode { from = "Elm" }
            , Limit 5
            ]
        )

subscriptions = watchSub chatMessageDecoder NewChatMessage
```
???
Here's what the previous simple chat app will look like in Elm.

On my init, I will call a watch command, passing in the collection name, in this case it's "chat_messages", 

and a List of modifiers, in this case a FindAll with the filter criteria as a Json value, 

and Limit of 5 to limit my data to only 5 rows.

and I'm subscribing to watch subscription, passing in the decoder to decode my chat message, 

and then passing in the result to NewChatMessage.

SO that's the read operation.
---
## insertCmd/Sub
```elm
insertCmd : String -> List Json.Value -> Cmd msg
insertCmd collectionName data = ...

insertSub : (Result Error () -> msg) -> Sub msg
insertSub resultTagger = ...
```
#### Example
```elm
update msg model = 
    case msg of
        Insert chatMessage -> 
            ( model, insertCmd "chat_messages" [ encode chatMessage ] )

subscriptions = insertSub InsertResponse
```
???
and for the write operation:

on my update function, I will call and insert command, 

passing in the name of the collection, in this case "chat_messages", and a list of chat message record, encoded as Json.Value.

and I'll subscribe to the insert subscription to get the status of my insert command.
---
class: center middle
# Demo
### Simple Chat App

???
And here's the end results. 
This chat app is written purely in Elm, using the Elm-Horizon library. 

There are some javascript code in the Elm-Horizon library itself, 

but the chat application is written only using elm, no javascript, and no backend code.
---
class: thanks center middle
# Thanks

.image[.elm-whale[![Elm Whale](images/elm-whale.png "Elm Whale")]]

#### Source Code 
[https://github.com/abadi199/elm-horizon](https://github.com/abadi199/elm-horizon)

#### Slide 
[https://abadi199.github.com/elm-conf](https://abadi199.github.com/elm-conf)
???
That's all I have today.
You can check out the source code for the elm horizon on my github repo, the code for the chat app is in the example folder.
and you can access my slide on my github page, at abadi199.github.com/elm-conf.

Thank you, and enjoy the rest of your conference.      
    </textarea>
    <script src="js/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        ratio: '16:9',
        // ratio: '4:3',
        highlightStyle: 'atom-one-light'
      });
    </script>
  </body>
</html>